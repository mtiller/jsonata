import { doEval } from "./eval2";
import { ProcedureDetails } from "./procs";
import { JBox, unbox, boxValue } from "./box";
import { JEnv } from "./environment";
import { Signature } from "../signatures";

/**
 * Apply procedure or function
 * @param {Object} proc - Procedure
 * @param {Array} args - Arguments
 * @param {Object} self - Self
 * @returns {*} Result of procedure
 */
export function apply(proc: JBox, args: JBox[], context: JBox): JBox {
    let result = applyInner(proc, args, context);
    while (result.lambda) {
        let details = result.values[0] as ProcedureDetails;
        if (details.thunk) {
            let body = details.body;
            if (body.type === "function" || body.type === "partial") {
                let node = body;
                // trampoline loop - this gets invoked as a result of tail-call optimization
                // the function returned a tail-call thunk
                // unpack it, evaluate its arguments, and apply the tail call
                var next = doEval(node.procedure, details.input, details.environment);
                var evaluatedArgs = [];
                for (var ii = 0; ii < node.arguments.length; ii++) {
                    evaluatedArgs.push(doEval(node.arguments[ii], details.input, details.environment));
                }
            } else {
                throw new Error("body in ProcedureDetails was not a FunctionInvocationNode");
            }

            result = applyInner(next, evaluatedArgs, context);
        }
    }
    return result;
}

/**
 * Apply procedure (ProcedureDetails) or function
 * @param {Object} proc - Procedure
 * @param {Array} args - Arguments
 * @param {Object} self - Self
 * @returns {*} Result of procedure
 */
function applyInner(proc: JBox, args: JBox[], context: JBox): JBox {
    var validatedArgs = args;

    // TODO: Could be a native function structure as well...but I don't have a
    // type for that yet.
    if (proc.lambda) {
        let details = proc.values[0] as ProcedureDetails;
        validatedArgs = validateArguments(details.signature, args, context);
        return applyProcedure(details, validatedArgs);
    } else {
        // TODO: Add a contingency for native functions and _jsonata_function values
        throw new Error("Attempted to call applyInner on non-lambda function");
    }

    // if (proc.lambda) {
    // } else if (proc && proc._jsonata_function === true) {
    //     result = proc.implementation.apply(self, validatedArgs);
    //     // `proc.implementation` might be a generator function
    //     // and `result` might be a generator - if so, yield
    //     if (isGenerator(result)) {
    //         result = yield * result;
    //     }
    // } else if (typeof proc === "function") {
    //     result = proc.apply(self, validatedArgs);
    //     /* istanbul ignore next */
    //     if (isGenerator(result)) {
    //         result = yield * result;
    //     }
    // } else {
    //     throw {
    //         code: "T1006",
    //         stack: new Error().stack,
    //     };
    // }
    // return result;
}

/**
 * Validate the arguments against the signature validator (if it exists)
 * @param {Function} signature - validator function
 * @param {Array} args - function arguments
 * @param {*} context - context value
 * @returns {Array} - validated arguments
 */
function validateArguments(signature: Signature, args: JBox[], context: JBox): JBox[] {
    if (typeof signature === "undefined") {
        // nothing to validate
        return args;
    }
    var validatedArgs = signature.validate(args.map(v => unbox(v)), context);
    return validatedArgs.map(x => boxValue(x));
}

/**
 * Apply procedure
 * @param {Object} proc - Procedure
 * @param {Array} args - Arguments
 * @returns {*} Result of procedure
 */
function applyProcedure(details: ProcedureDetails, args: JBox[]) {
    let env = new JEnv();

    details.arguments.forEach((param, index) => {
        env.bind(param.value, args[index]);
    });
    if (typeof details.body === "function") {
        // this is a lambda that wraps a native function - generated by partially evaluating a native
        return applyNativeFunction(details.body, env);
    } else {
        return doEval(details.body, details.input, env);
    }
}

/**
 * Apply native function
 * @param {Object} proc - Procedure
 * @param {Object} env - Environment
 * @returns {*} Result of applying native function
 */
function applyNativeFunction(f: Function, env: JEnv) {
    var sigArgs = getNativeFunctionArguments(f);
    // generate the array of arguments for invoking the function - look them up in the environment
    var args = sigArgs.map(function(sigArg) {
        return env.lookup(sigArg.trim());
    });

    return f.apply(null, args);
}

/**
 * Get native function arguments
 * @param {Function} func - Function
 * @returns {*|Array} Native function arguments
 */
function getNativeFunctionArguments(func: Function) {
    var signature = func.toString();
    var sigParens = /\(([^)]*)\)/.exec(signature)[1]; // the contents of the parens
    var sigArgs = sigParens.split(",");
    return sigArgs;
}
